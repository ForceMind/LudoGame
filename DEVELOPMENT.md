# Ludo Battle 开发文档

本文档旨在为后端开发人员、AI 或新加入的贡献者提供项目的完整技术概览。它详细描述了游戏架构、核心逻辑流程、状态管理以及关键算法实现。

## 1. 项目架构概览

本项目采用经典的 **MVC (Model-View-Controller)** 变体架构，完全基于原生 JavaScript (ES6+) 和 HTML5 Canvas 实现。

### 1.1 文件职责划分

*   **`index.html`**: 游戏入口，包含 Canvas 容器和 UI DOM 元素（如控制面板、调试信息）。
*   **`js/ludo.js` (Model)**:
    *   定义棋盘数据结构（坐标映射、路径定义）。
    *   维护棋盘状态（哪些格子有棋子）。
    *   提供坐标转换工具（逻辑坐标 -> Canvas 像素坐标）。
*   **`js/game.js` (Controller)**:
    *   **核心控制器**：管理游戏主循环、回合流转、胜负判定。
    *   **状态机**：维护 `isGameActive`, `currentPlayerId`, `turnState` 等全局状态。
    *   **计时系统**：处理游戏时长统计、暂停/恢复逻辑 (`visibilitychange`)。
*   **`js/ui.js` (View)**:
    *   负责 Canvas 的所有绘制工作（棋盘、棋子、动画）。
    *   处理 DOM UI 更新（如骰子动画、提示信息、计时器显示）。
    *   处理用户输入（点击事件）。
*   **`js/ai.js` (Logic/Service)**:
    *   封装所有 AI 决策逻辑。
    *   实现胜率预测模型、Sigmoid 概率控制、干预机制。
*   **`js/player.js`**: 玩家实体类，存储玩家状态（棋子位置、颜色、ID）。
*   **`js/utils.js`**: 通用工具函数（随机数、数学计算）。

## 2. 核心游戏流程 (Game Loop)

游戏并非采用传统的帧同步循环，而是基于 **事件驱动的回合制** 流程，辅以 Canvas 的渲染循环。

### 2.1 回合生命周期

1.  **回合开始 (`startTurn`)**:
    *   检查当前玩家是否为 AI。
    *   如果是 AI，触发 `AIController.rollDice` 并自动执行移动。
    *   如果是人类，解锁骰子按钮，等待用户点击。
2.  **掷骰子 (`rollDice`)**:
    *   调用 `AIController` 获取点数（即使是人类玩家，点数也受 AI 概率模型控制以平衡胜率）。
    *   播放骰子动画。
3.  **移动判定**:
    *   计算当前点数下所有合法的移动步数。
    *   如果没有合法移动（如点数过大无法进终点，或未起飞且非6点），直接切换下一玩家。
4.  **执行移动 (`movePiece`)**:
    *   更新棋子坐标。
    *   **吃子检测**：如果终点格有敌方棋子且非安全区，触发吃子逻辑（敌方回基地，当前玩家获奖励回合）。
    *   **终点检测**：如果棋子到达终点，检查是否所有棋子均到达（获胜判定）。
5.  **回合结束/切换**:
    *   如果获得奖励回合（掷出6、吃子、到终点），当前玩家继续。
    *   否则，`currentPlayerId` 轮转，调用 `startTurn` 开始下一回合。

## 3. 关键系统详解

### 3.1 计时与暂停系统 (`game.js`)

为了准确统计玩家的有效游戏时间，系统实现了防挂机和后台暂停机制。

*   **数据结构**:
    *   `gameStartTime`: 游戏初始化的时间戳。
    *   `totalPausedTime`: 累积的暂停时长（毫秒）。
    *   `lastPauseStartTime`: 上次进入后台的时间戳。
*   **逻辑**:
    *   监听 `document.visibilitychange` 事件。
    *   当页面隐藏 (`hidden`) 时，记录 `lastPauseStartTime`。
    *   当页面恢复 (`visible`) 时，计算 `now - lastPauseStartTime` 并累加到 `totalPausedTime`。
    *   **显示时间** = `Date.now() - gameStartTime - totalPausedTime`。

### 3.2 AI 概率控制系统 (`ai.js`)

游戏的核心特色是基于胜率预测的动态难度调整。

#### A. 胜率预测
系统实时计算每个玩家的“预测胜率”，公式为：
`WinRate = (0.5 * StructureScore + 0.5 * ProgressScore) / 100`
*   **StructureScore**: 棋子位置加权分（基地5, 路上15, 安全区20, 终点25）。
*   **ProgressScore**: 归一化的进度分（1 - 剩余步数/总步数）。

#### B. Sigmoid 概率干预
根据 `(玩家胜率 - 平均胜率)` 计算 `Influence` 值，代入 Sigmoid 函数决定掷出 **Group A (1-5)** 还是 **Group B (6)** 的概率。
*   **优势玩家**：`Influence` 高 -> Group A 概率高 -> 难掷出 6。
*   **劣势玩家**：`Influence` 低 -> Group A 概率低 -> 易掷出 6。

#### C. 游戏节奏加速 (Pacing)
为了防止游戏拖沓，引入了多层加速机制：
1.  **开局加速**: 基地棋子多时，强制提高 6 点概率。
2.  **移动加速**: 当决定掷出 Group A (1-5) 时，**80% 概率** 选取 {3, 4, 5}，**20% 概率** 选取 {1, 2}。
3.  **时间系数**: 随着游戏回合数增加（0-120回合），AI 的攻击欲望（吃子概率）和推进欲望会动态变化。

### 3.3 坐标与渲染系统 (`ludo.js` & `ui.js`)

*   **逻辑坐标**: 棋盘被抽象为路径数组。
    *   `0-51`: 通用环形路径。
    *   `100-105`: 玩家 0 的终点直道。
    *   `200-205`: 玩家 1 的终点直道，以此类推。
    *   `-1`: 基地。
    *   `999`: 终点。
*   **渲染坐标**: `ludo.js` 中的 `coordinates` 映射表将逻辑索引转换为 Canvas 的 `(x, y)` 像素坐标。
*   **重叠处理**: `ui.js` 检测同一格内的棋子数量，动态计算偏移量 (`scale`, `offsetX`, `offsetY`)，确保多枚棋子重叠时能呈梅花状或网格状排列。

## 4. 数据持久化

使用 `localStorage` 保存用户长期数据：
*   `ludo_balance`: 用户虚拟货币余额。
*   `ludo_win_rate`: 用户历史胜率记录（用于计算基础平衡值）。

## 5. 调试与监控

游戏内置了强大的调试面板（UI左侧），实时展示：
*   当前触发的 AI 逻辑（如 "Failsafe", "Capture Intervention"）。
*   各玩家的实时预测胜率。
*   当前的骰子概率分布参数。

---
*文档最后更新时间: 2025-12-04*
